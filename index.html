<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>dash dodge</title>
  <style>
    html, body { 
      margin:0; height:100%; 
      background: radial-gradient(ellipse at center, #1a1f2e 0%, #0b0f14 100%);
      font-family: system-ui, -apple-system, segoe ui, roboto, arial;
      overflow: hidden;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
    }
    canvas { 
      display:block; margin:0 auto; 
      background: radial-gradient(ellipse at center, #1a1f2e 0%, #0b0f14 100%);
      box-shadow: 0 0 100px rgba(0,0,0,0.8);
    }

    /* skin overlay */
    #skinOverlay{
      position:fixed; inset:0;
      display:flex; align-items:center; justify-content:center;
      background: radial-gradient(ellipse at center, rgba(26,31,46,0.96) 0%, rgba(11,15,20,0.98) 100%);
      backdrop-filter: blur(12px);
      animation: fadeIn 0.3s ease;
    }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    
    #panel{
      width:min(520px, calc(100% - 32px));
      border:1px solid rgba(110,231,183,0.2);
      border-radius:20px;
      padding:24px;
      background: linear-gradient(135deg, rgba(26,31,46,0.8) 0%, rgba(15,20,30,0.9) 100%);
      box-shadow: 
        0 20px 60px rgba(0,0,0,0.5),
        0 0 40px rgba(110,231,183,0.1),
        inset 0 1px 0 rgba(255,255,255,0.1);
      color:#e5e7eb;
      transform: scale(0.95);
      animation: popIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
    }
    @keyframes popIn {
      to { transform: scale(1); }
    }
    #title{ 
      font-size:24px; 
      margin:0 0 8px 0; 
      font-weight:700;
      background: linear-gradient(135deg, #6ee7b7 0%, #9ae6ff 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    #sub{ font-size:13px; opacity:0.7; margin:0 0 20px 0; line-height:1.5; }
    .row{ display:flex; gap:12px; align-items:center; margin:10px 0; }
    label{ font-size:13px; opacity:0.85; width:120px; }
    select, button{
      width:100%;
      padding:12px 14px;
      border-radius:12px;
      border:1px solid rgba(110,231,183,0.15);
      background: linear-gradient(135deg, rgba(26,31,46,0.6) 0%, rgba(15,20,30,0.8) 100%);
      color:#e5e7eb;
      outline:none;
      font-size:14px;
      transition: all 0.2s ease;
    }
    select:hover, select:focus {
      border-color: rgba(110,231,183,0.3);
      background: linear-gradient(135deg, rgba(26,31,46,0.8) 0%, rgba(15,20,30,0.9) 100%);
    }
    button{ 
      cursor:pointer;
      font-weight:600;
      background: linear-gradient(135deg, #6ee7b7 0%, #4ade80 100%);
      border:1px solid rgba(110,231,183,0.3);
      color:#0b0f14;
      box-shadow: 
        0 4px 12px rgba(110,231,183,0.3),
        inset 0 1px 0 rgba(255,255,255,0.2);
    }
    button:hover{ 
      background: linear-gradient(135deg, #7ff0c7 0%, #5be890 100%);
      box-shadow: 
        0 6px 20px rgba(110,231,183,0.4),
        inset 0 1px 0 rgba(255,255,255,0.3);
      transform: translateY(-1px);
    }
    button:active {
      transform: translateY(0);
    }

    #previewWrap{
      display:flex; gap:12px; align-items:center; margin-top:14px;
      padding:12px; border-radius:14px;
      border:1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.03);
    }
    #preview{
      width:64px; height:64px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.25);
      display:flex; align-items:center; justify-content:center;
    }
    #tip{ font-size:12px; opacity:0.75; line-height:1.4; }
    .pill{
      display:inline-block;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      font-size:12px;
      opacity:0.9;
    }

    /* Mobile touch controls */
    #touchControls {
      display: none;
      position: fixed;
      bottom: 0; left: 0; right: 0;
      height: 220px;
      pointer-events: none;
      z-index: 10;
    }
    #joystickZone {
      position: absolute;
      left: 20px; bottom: 20px;
      width: 140px; height: 140px;
      pointer-events: all;
    }
    #joystickBase {
      position: absolute;
      inset: 0;
      border-radius: 50%;
      background: rgba(110,231,183,0.08);
      border: 2px solid rgba(110,231,183,0.25);
    }
    #joystickThumb {
      position: absolute;
      width: 52px; height: 52px;
      border-radius: 50%;
      background: radial-gradient(circle at 35% 35%, #6ee7b7, #2a9d6f);
      border: 2px solid rgba(255,255,255,0.3);
      box-shadow: 0 4px 16px rgba(110,231,183,0.4);
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      transition: none;
    }
    #dashBtn {
      position: absolute;
      right: 24px; bottom: 30px;
      width: 80px; height: 80px;
      border-radius: 50%;
      background: radial-gradient(circle at 35% 35%, rgba(110,231,183,0.3), rgba(110,231,183,0.08));
      border: 2px solid rgba(110,231,183,0.4);
      box-shadow: 0 4px 20px rgba(110,231,183,0.25);
      pointer-events: all;
      display: flex; align-items: center; justify-content: center;
      color: #6ee7b7;
      font-size: 12px;
      font-weight: 700;
      font-family: system-ui, -apple-system, segoe ui, roboto, arial;
      letter-spacing: 0.05em;
      -webkit-tap-highlight-color: transparent;
    }
    #dashBtn.active {
      background: radial-gradient(circle at 35% 35%, rgba(110,231,183,0.55), rgba(110,231,183,0.2));
      box-shadow: 0 0 28px rgba(110,231,183,0.6);
    }
    #restartBtnTouch {
      position: absolute;
      right: 120px; bottom: 42px;
      width: 56px; height: 56px;
      border-radius: 50%;
      background: rgba(255,255,255,0.06);
      border: 2px solid rgba(255,255,255,0.15);
      pointer-events: all;
      display: flex; align-items: center; justify-content: center;
      color: #9ca3af;
      font-size: 11px;
      font-weight: 700;
      font-family: system-ui, -apple-system, segoe ui, roboto, arial;
      -webkit-tap-highlight-color: transparent;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<div id="skinOverlay">
  <div id="panel">
    <p id="title">player skin</p>
    <p id="sub">pick your ball look, then press play. press esc anytime to come back here.</p>

    <div class="row">
      <label>shape</label>
      <select id="shapeSel">
        <option value="circle">circle</option>
        <option value="square">square</option>
        <option value="triangle">triangle</option>
      </select>
    </div>

    <div class="row">
      <label>color</label>
      <select id="colorSel"></select>
    </div>

    <div id="previewWrap">
      <div id="preview">
        <canvas id="p" width="64" height="64"></canvas>
      </div>
      <div id="tip">
        controls: <span class="pill">arrows / wasd</span> <span class="pill">space dash</span> <span class="pill">r restart</span><br>
        mobile: <span class="pill">joystick</span> <span class="pill">dash btn</span><br>
        new: <span class="pill">esc</span> to open skins
      </div>
    </div>

    <div class="row" style="margin-top:14px;">
      <button id="playBtn">play</button>
    </div>
  </div>
</div>

<!-- Mobile touch controls -->
<div id="touchControls">
  <div id="joystickZone">
    <div id="joystickBase"></div>
    <div id="joystickThumb"></div>
  </div>
  <div id="restartBtnTouch">R</div>
  <div id="dashBtn">DASH</div>
</div>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function fit() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", fit);
fit();

const keys = new Set();
window.addEventListener("keydown", e => {
  keys.add(e.key.toLowerCase());
  if (["arrowup","arrowdown","arrowleft","arrowright"," "].includes(e.key.toLowerCase())) e.preventDefault();
});
window.addEventListener("keyup", e => keys.delete(e.key.toLowerCase()));

function rand(a,b){ return a + Math.random()*(b-a); }
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function len(x,y){ return Math.hypot(x,y); }

/* -------- mobile detection & touch controls -------- */
const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
const touchControls = document.getElementById("touchControls");
const joystickZone = document.getElementById("joystickZone");
const joystickThumb = document.getElementById("joystickThumb");
const dashBtn = document.getElementById("dashBtn");
const restartBtnTouch = document.getElementById("restartBtnTouch");

if (isMobile) {
  touchControls.style.display = "block";
  // Shrink canvas bottom padding so controls don't overlap
  canvas.style.marginBottom = "220px";
  canvas.style.height = "calc(100vh - 220px)";
}

// Virtual joystick state
const joystick = { active: false, touchId: null, ax: 0, ay: 0, startX: 0, startY: 0 };
const JOYSTICK_RADIUS = 44; // max thumb travel

joystickZone.addEventListener("touchstart", e => {
  e.preventDefault();
  const t = e.changedTouches[0];
  const rect = joystickZone.getBoundingClientRect();
  joystick.active = true;
  joystick.touchId = t.identifier;
  joystick.startX = rect.left + rect.width / 2;
  joystick.startY = rect.top + rect.height / 2;
  updateJoystick(t.clientX, t.clientY);
}, { passive: false });

joystickZone.addEventListener("touchmove", e => {
  e.preventDefault();
  for (const t of e.changedTouches) {
    if (t.identifier === joystick.touchId) {
      updateJoystick(t.clientX, t.clientY);
    }
  }
}, { passive: false });

function endJoystick() {
  joystick.active = false;
  joystick.touchId = null;
  joystick.ax = 0;
  joystick.ay = 0;
  joystickThumb.style.transform = "translate(-50%, -50%)";
}

joystickZone.addEventListener("touchend", e => { e.preventDefault(); endJoystick(); }, { passive: false });
joystickZone.addEventListener("touchcancel", e => { e.preventDefault(); endJoystick(); }, { passive: false });

function updateJoystick(cx, cy) {
  const dx = cx - joystick.startX;
  const dy = cy - joystick.startY;
  const d = Math.hypot(dx, dy);
  const clamped = Math.min(d, JOYSTICK_RADIUS);
  const angle = Math.atan2(dy, dx);
  joystick.ax = Math.cos(angle) * (clamped / JOYSTICK_RADIUS);
  joystick.ay = Math.sin(angle) * (clamped / JOYSTICK_RADIUS);
  const tx = Math.cos(angle) * clamped;
  const ty = Math.sin(angle) * clamped;
  joystickThumb.style.transform = `translate(calc(-50% + ${tx}px), calc(-50% + ${ty}px))`;
}

// Dash button
let dashTouched = false;
dashBtn.addEventListener("touchstart", e => {
  e.preventDefault();
  dashTouched = true;
  dashBtn.classList.add("active");
  keys.add(" ");
}, { passive: false });
dashBtn.addEventListener("touchend", e => {
  e.preventDefault();
  dashTouched = false;
  dashBtn.classList.remove("active");
  keys.delete(" ");
}, { passive: false });
dashBtn.addEventListener("touchcancel", e => {
  dashTouched = false;
  dashBtn.classList.remove("active");
  keys.delete(" ");
});

// Restart button (touch)
restartBtnTouch.addEventListener("touchstart", e => {
  e.preventDefault();
  keys.add("r");
}, { passive: false });
restartBtnTouch.addEventListener("touchend", e => {
  e.preventDefault();
  setTimeout(() => keys.delete("r"), 100);
}, { passive: false });

/* -------- skins -------- */
const overlay = document.getElementById("skinOverlay");
const shapeSel = document.getElementById("shapeSel");
const colorSel = document.getElementById("colorSel");
const playBtn = document.getElementById("playBtn");

const previewCanvas = document.getElementById("p");
const pctx = previewCanvas.getContext("2d");

const palette = [
  { name: "mint", value: "#6ee7b7" },
  { name: "ice", value: "#9ae6ff" },
  { name: "rose", value: "#ff4d6d" },
  { name: "amber", value: "#ffb86b" },
  { name: "violet", value: "#c4b5fd" },
  { name: "lime", value: "#a3e635" },
  { name: "white", value: "#e5e7eb" }
];

for (const c of palette) {
  const opt = document.createElement("option");
  opt.value = c.value;
  opt.textContent = c.name;
  colorSel.appendChild(opt);
}

let skin = { shape:"circle", color:"#6ee7b7" };
shapeSel.value = skin.shape;
colorSel.value = skin.color;

function drawPlayerShape(gctx, x, y, r, shape, color, alpha=1) {
  gctx.save();
  gctx.globalAlpha = alpha;
  gctx.fillStyle = color;

  if (shape === "circle") {
    gctx.beginPath();
    gctx.arc(x, y, r, 0, Math.PI*2);
    gctx.fill();
  } else if (shape === "square") {
    const s = r * 1.8;
    gctx.fillRect(x - s/2, y - s/2, s, s);
  } else if (shape === "triangle") {
    const s = r * 2.0;
    gctx.beginPath();
    gctx.moveTo(x, y - s/2);
    gctx.lineTo(x - s/2, y + s/2);
    gctx.lineTo(x + s/2, y + s/2);
    gctx.closePath();
    gctx.fill();
  }

  gctx.restore();
}

function updatePreview() {
  pctx.clearRect(0,0,64,64);
  pctx.fillStyle = "rgba(255,255,255,0.05)";
  pctx.fillRect(0,0,64,64);
  drawPlayerShape(pctx, 32, 32, 14, shapeSel.value, colorSel.value, 1);
}

shapeSel.addEventListener("change", () => {
  skin.shape = shapeSel.value;
  updatePreview();
});
colorSel.addEventListener("change", () => {
  skin.color = colorSel.value;
  updatePreview();
});
updatePreview();

function openSkins() {
  overlay.style.display = "flex";
  if (isMobile) touchControls.style.display = "none";
}
function closeSkins() {
  overlay.style.display = "none";
  if (isMobile) touchControls.style.display = "block";
}

playBtn.addEventListener("click", () => {
  skin = { shape: shapeSel.value, color: colorSel.value };
  closeSkins();
  if (!gameStarted) startGame();
});

window.addEventListener("keydown", (e) => {
  if (e.key.toLowerCase() === "escape") {
    openSkins();
  }
});

/* -------- game -------- */
let best = 0;
let gameStarted = false;

function startGame() {
  gameStarted = true;

  const w = canvas.width, h = canvas.height;

  const player = {
    x: w*0.5, y: h*0.5,
    r: 10,
    vx: 0, vy: 0,
    dashCd: 0,
    inv: 0
  };

  const orbs = [];
  const bombs = [];
  const pulses = [];
  const particles = [];
  const trails = [];
  const floatingTexts = [];

  let t = 0;
  let score = 0;
  let alive = true;
  let multiplier = 1;
  let streakTimer = 0;
  let lastHitTime = 0;
  let comboCount = 0;

  const comboMessages = [
    { threshold: 3, text: "NICE!", color: "#6ee7b7" },
    { threshold: 5, text: "GREAT!", color: "#9ae6ff" },
    { threshold: 8, text: "AWESOME!", color: "#a3e635" },
    { threshold: 12, text: "INCREDIBLE!", color: "#ffb86b" },
    { threshold: 16, text: "UNSTOPPABLE!", color: "#c4b5fd" },
    { threshold: 20, text: "LEGENDARY!", color: "#ff4d6d" },
    { threshold: 25, text: "GOD MODE!", color: "#fbbf24" }
  ];

  function addFloatingText(x, y, text, color, size = 20) {
    floatingTexts.push({
      x, y,
      text,
      color,
      size,
      life: 1.5,
      vy: -60
    });
  }

  function createParticles(x, y, color, count = 12) {
    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 * i) / count + rand(-0.2, 0.2);
      const speed = rand(80, 180);
      particles.push({
        x, y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life: 1,
        decay: rand(1.8, 2.8),
        r: rand(2, 5),
        color
      });
    }
  }

  function addTrail(x, y, color, size = 8) {
    trails.push({ x, y, life: 1, r: size, color });
  }

  function spawnOrb() {
    const cw = canvas.width, ch = canvas.height;
    const side = Math.floor(rand(0,4));
    let x, y;
    if (side === 0) { x = -20; y = rand(0,ch); }
    if (side === 1) { x = cw+20; y = rand(0,ch); }
    if (side === 2) { x = rand(0,cw); y = -20; }
    if (side === 3) { x = rand(0,cw); y = ch+20; }

    const speed = rand(70, 150) + Math.min(score*0.2, 120);
    const ang = Math.atan2(player.y - y, player.x - x) + rand(-0.35, 0.35);
    orbs.push({
      x, y,
      r: rand(8, 14),
      vx: Math.cos(ang)*speed,
      vy: Math.sin(ang)*speed
    });
  }

  function spawnBomb() {
    const cw = canvas.width, ch = canvas.height;
    bombs.push({
      x: rand(60, cw-60),
      y: rand(60, ch-60),
      r: 14,
      fuse: rand(1.2, 2.2),
      boom: false
    });
  }

  function explode(b) {
    b.boom = true;
    const ring = { x:b.x, y:b.y, r:0, max: rand(130, 200), speed: rand(260, 360) };
    pulses.push(ring);
    createParticles(b.x, b.y, "#9ae6ff", 24);

    let hitCount = 0;
    for (let i = orbs.length-1; i >= 0; i--) {
      const o = orbs[i];
      const d = len(o.x - b.x, o.y - b.y);
      if (d < ring.max*0.65) {
        createParticles(o.x, o.y, "#ff4d6d", 8);
        orbs.splice(i,1);
        hitCount++;
        comboCount++;
        score += 6 * multiplier;
        addFloatingText(o.x, o.y, "+" + Math.floor(6 * multiplier), "#6ee7b7", 16);
      } else if (d < ring.max) {
        const k = (ring.max - d) / ring.max;
        const ax = (o.x - b.x) / (d || 1);
        const ay = (o.y - b.y) / (d || 1);
        o.vx += ax * 220 * k;
        o.vy += ay * 220 * k;
      }
    }

    if (hitCount > 0) {
      lastHitTime = t;
      streakTimer = 3;
      
      for (let i = comboMessages.length - 1; i >= 0; i--) {
        if (comboCount >= comboMessages[i].threshold && comboCount < comboMessages[i].threshold + hitCount) {
          addFloatingText(b.x, b.y - 30, comboMessages[i].text, comboMessages[i].color, 28);
          createParticles(b.x, b.y, comboMessages[i].color, 16);
          break;
        }
      }
    }
  }

  function reset() {
    const cw = canvas.width, ch = canvas.height;
    orbs.length = 0;
    bombs.length = 0;
    pulses.length = 0;
    particles.length = 0;
    trails.length = 0;
    floatingTexts.length = 0;
    player.x = cw*0.5; player.y = ch*0.5;
    player.vx = 0; player.vy = 0;
    player.dashCd = 0; player.inv = 0;
    t = 0; score = 0; alive = true;
    multiplier = 1;
    streakTimer = 0;
    lastHitTime = 0;
    comboCount = 0;
  }

  let orbTimer = 0;
  let bombTimer = 0;

  function step(dt) {
    if (keys.has("r")) reset();

    if (!alive) {
      for (const o of orbs) { o.x += o.vx*dt; o.y += o.vy*dt; }
      for (const p of pulses) { p.r = Math.min(p.max, p.r + p.speed*dt); }
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vx *= 0.98;
        p.vy *= 0.98;
        p.life -= p.decay * dt;
        if (p.life <= 0) particles.splice(i, 1);
      }
      return;
    }

    t += dt;
    
    streakTimer = Math.max(0, streakTimer - dt);
    if (streakTimer <= 0) {
      if (multiplier > 1) {
        multiplier = Math.max(1, multiplier - dt * 0.5);
      }
      if (comboCount > 0) {
        comboCount = Math.max(0, comboCount - dt * 2);
      }
    } else {
      const targetMultiplier = 1 + Math.min(comboCount * 0.15, 4);
      multiplier = multiplier + (targetMultiplier - multiplier) * dt * 3;
    }
    
    score += dt * 1.8 * multiplier;
    best = Math.max(best, Math.floor(score));

    orbTimer -= dt;
    const orbGap = Math.max(0.18, 0.7 - Math.min(score*0.002, 0.5));
    if (orbTimer <= 0) { spawnOrb(); orbTimer = orbGap; }

    bombTimer -= dt;
    const bombGap = Math.max(2.2, 4.5 - Math.min(score*0.004, 2.0));
    if (bombTimer <= 0) { spawnBomb(); bombTimer = bombGap; }

    // Input: keyboard + virtual joystick
    let ax = 0, ay = 0;
    const up = keys.has("arrowup") || keys.has("w");
    const down = keys.has("arrowdown") || keys.has("s");
    const left = keys.has("arrowleft") || keys.has("a");
    const right = keys.has("arrowright") || keys.has("d");
    if (up) ay -= 1;
    if (down) ay += 1;
    if (left) ax -= 1;
    if (right) ax += 1;

    // Add joystick input
    if (joystick.active) {
      ax += joystick.ax;
      ay += joystick.ay;
    }

    const mag = Math.hypot(ax, ay) || 1;
    ax /= mag; ay /= mag;

    const accel = 10000;
    player.vx += ax * accel * dt;
    player.vy += ay * accel * dt;

    player.dashCd = Math.max(0, player.dashCd - dt);
    if (player.inv > 0) player.inv -= dt;

    const dashPressed = keys.has(" ");
    if (dashPressed && player.dashCd <= 0) {
      const dirMag = Math.hypot(player.vx, player.vy);
      let dx, dy;
      if (dirMag > 1) {
        dx = player.vx / dirMag;
        dy = player.vy / dirMag;
      } else {
        dx = ax; dy = ay;
        if (Math.hypot(dx,dy) < 0.1) { dx = 1; dy = 0; }
      }
      player.vx += dx * 520;
      player.vy += dy * 520;
      player.dashCd = 0.75;
      player.inv = 0.18;
      createParticles(player.x, player.y, skin.color, 16);
    }

    const friction = 0.86;
    player.vx *= Math.pow(friction, dt*60);
    player.vy *= Math.pow(friction, dt*60);

    const maxSpd = 320;
    const spd = Math.hypot(player.vx, player.vy);
    if (spd > maxSpd) {
      player.vx = player.vx/spd * maxSpd;
      player.vy = player.vy/spd * maxSpd;
    }

    player.x += player.vx * dt;
    player.y += player.vy * dt;

    const cw = canvas.width, ch = canvas.height;
    const pad = 18;
    player.x = clamp(player.x, pad, cw - pad);
    player.y = clamp(player.y, pad, ch - pad);

    if (Math.random() < 0.3) {
      addTrail(player.x, player.y, skin.color, player.r * 0.7);
    }

    for (const o of orbs) {
      o.x += o.vx * dt;
      o.y += o.vy * dt;
      
      if (Math.random() < 0.2) {
        addTrail(o.x, o.y, "#ff4d6d", o.r * 0.6);
      }
      
      const toX = player.x - o.x;
      const toY = player.y - o.y;
      const d = Math.hypot(toX,toY) || 1;
      const turn = 40 + Math.min(score*0.02, 55);
      o.vx += (toX/d) * turn * dt;
      o.vy += (toY/d) * turn * dt;
      const os = Math.hypot(o.vx,o.vy);
      const omax = 240 + Math.min(score*0.25, 220);
      if (os > omax) { o.vx = o.vx/os * omax; o.vy = o.vy/os * omax; }
    }

    for (let i=bombs.length-1;i>=0;i--) {
      const b = bombs[i];
      b.fuse -= dt;
      if (!b.boom && b.fuse <= 0) explode(b);
      if (b.boom && b.fuse <= -0.3) bombs.splice(i,1);
    }

    for (let i=pulses.length-1;i>=0;i--) {
      const p = pulses[i];
      p.r += p.speed * dt;
      if (p.r >= p.max) pulses.splice(i,1);
    }

    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= 0.98;
      p.vy *= 0.98;
      p.life -= p.decay * dt;
      if (p.life <= 0) particles.splice(i, 1);
    }

    for (let i = trails.length - 1; i >= 0; i--) {
      const tr = trails[i];
      tr.life -= 3.5 * dt;
      if (tr.life <= 0) trails.splice(i, 1);
    }

    for (let i = floatingTexts.length - 1; i >= 0; i--) {
      const ft = floatingTexts[i];
      ft.y += ft.vy * dt;
      ft.life -= dt;
      if (ft.life <= 0) floatingTexts.splice(i, 1);
    }

    if (player.inv <= 0) {
      for (const o of orbs) {
        const d = len(player.x - o.x, player.y - o.y);
        if (d < player.r + o.r) { 
          alive = false; 
          createParticles(player.x, player.y, skin.color, 20);
          break; 
        }
      }
      for (const p of pulses) {
        const d = len(player.x - p.x, player.y - p.y);
        if (d < p.r + player.r && d > p.r - 12) { 
          alive = false; 
          createParticles(player.x, player.y, skin.color, 20);
          break; 
        }
      }
    }

    for (const b of bombs) {
      if (b.boom) continue;
      const d = len(player.x - b.x, player.y - b.y);
      if (d < 42) {
        score += dt * 4.2 * multiplier;
      }
    }
  }

  function draw() {
    const w = canvas.width, h = canvas.height;
    
    const grad = ctx.createRadialGradient(w/2, h/2, 0, w/2, h/2, Math.max(w, h));
    grad.addColorStop(0, '#1a1f2e');
    grad.addColorStop(1, '#0b0f14');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, w, h);

    ctx.globalAlpha = 0.03 + 0.02 * Math.sin(t * 0.5);
    ctx.strokeStyle = "#6ee7b7";
    ctx.lineWidth = 1;
    const offset = (t * 20) % 40;
    for (let x = -offset; x < w; x += 40) { 
      ctx.beginPath(); 
      ctx.moveTo(x, 0); 
      ctx.lineTo(x, h); 
      ctx.stroke(); 
    }
    for (let y = -offset; y < h; y += 40) { 
      ctx.beginPath(); 
      ctx.moveTo(0, y); 
      ctx.lineTo(w, y); 
      ctx.stroke(); 
    }
    ctx.globalAlpha = 1;

    for (const tr of trails) {
      ctx.globalAlpha = tr.life * 0.4;
      ctx.fillStyle = tr.color;
      ctx.beginPath();
      ctx.arc(tr.x, tr.y, tr.r, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    for (const p of particles) {
      ctx.globalAlpha = p.life * 0.8;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    for (const ft of floatingTexts) {
      ctx.globalAlpha = Math.min(1, ft.life);
      ctx.fillStyle = ft.color;
      ctx.font = `bold ${ft.size}px system-ui, -apple-system, segoe ui, roboto, arial`;
      ctx.textAlign = "center";
      ctx.shadowBlur = 8;
      ctx.shadowColor = ft.color;
      ctx.fillText(ft.text, ft.x, ft.y);
      ctx.shadowBlur = 0;
    }
    ctx.globalAlpha = 1;

    for (const p of pulses) {
      const progress = p.r / p.max;
      
      ctx.globalAlpha = (1 - progress) * 0.4;
      ctx.strokeStyle = "#9ae6ff";
      ctx.lineWidth = 8;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.stroke();
      
      ctx.globalAlpha = (1 - progress) * 0.9;
      ctx.strokeStyle = "#9ae6ff";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.stroke();
      
      ctx.globalAlpha = 1;
    }

    for (const b of bombs) {
      const blink = Math.max(0, Math.min(1, 1 - b.fuse/2.2));
      const pulse = 0.55 + 0.45 * Math.sin((1 + blink * 8) * t * 6);
      
      if (!b.boom) {
        const dangerGrad = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, 42);
        dangerGrad.addColorStop(0, 'rgba(255,184,107,0.15)');
        dangerGrad.addColorStop(1, 'rgba(255,184,107,0)');
        ctx.fillStyle = dangerGrad;
        ctx.fillRect(b.x - 42, b.y - 42, 84, 84);
        
        const bombGrad = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, b.r * 2);
        bombGrad.addColorStop(0, 'rgba(255,184,107,' + pulse * 0.6 + ')');
        bombGrad.addColorStop(1, 'rgba(255,184,107,0)');
        ctx.fillStyle = bombGrad;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r * 2, 0, Math.PI * 2);
        ctx.fill();
      }
      
      ctx.fillStyle = b.boom ? "#9ae6ff" : "#ffb86b";
      ctx.globalAlpha = b.boom ? 0.25 : pulse;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    for (const o of orbs) {
      const orbGrad = ctx.createRadialGradient(o.x, o.y, 0, o.x, o.y, o.r * 2);
      orbGrad.addColorStop(0, 'rgba(255,77,109,0.6)');
      orbGrad.addColorStop(1, 'rgba(255,77,109,0)');
      ctx.fillStyle = orbGrad;
      ctx.beginPath();
      ctx.arc(o.x, o.y, o.r * 2, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.fillStyle = "#ff4d6d";
      ctx.globalAlpha = 0.95;
      ctx.beginPath();
      ctx.arc(o.x, o.y, o.r, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.globalAlpha = 0.4;
      ctx.fillStyle = "#ff8fa3";
      ctx.beginPath();
      ctx.arc(o.x - o.r * 0.3, o.y - o.r * 0.3, o.r * 0.4, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.globalAlpha = 1;
    }

    const alpha = player.inv > 0 ? 0.35 : 1;
    
    if (player.inv <= 0) {
      const playerGrad = ctx.createRadialGradient(player.x, player.y, 0, player.x, player.y, player.r * 2.5);
      playerGrad.addColorStop(0, skin.color + '80');
      playerGrad.addColorStop(1, skin.color + '00');
      ctx.fillStyle = playerGrad;
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.r * 2.5, 0, Math.PI * 2);
      ctx.fill();
    }
    
    drawPlayerShape(ctx, player.x, player.y, player.r, skin.shape, skin.color, alpha);

    ctx.fillStyle = "rgba(26,31,46,0.6)";
    ctx.strokeStyle = "rgba(110,231,183,0.2)";
    ctx.lineWidth = 1;
    
    ctx.beginPath();
    ctx.roundRect(10, 10, 140, 90, 12);
    ctx.fill();
    ctx.stroke();
    
    ctx.fillStyle = "#e5e7eb";
    ctx.font = "bold 16px system-ui, -apple-system, segoe ui, roboto, arial";
    ctx.textAlign = "left";
    ctx.fillText("SCORE", 20, 30);
    ctx.font = "24px system-ui, -apple-system, segoe ui, roboto, arial";
    ctx.fillStyle = "#6ee7b7";
    ctx.fillText(Math.floor(score), 20, 55);
    
    if (multiplier > 1.1) {
      const multColor = multiplier >= 4 ? "#fbbf24" : multiplier >= 3 ? "#ff4d6d" : multiplier >= 2 ? "#c4b5fd" : "#9ae6ff";
      ctx.fillStyle = multColor;
      ctx.font = "bold 14px system-ui, -apple-system, segoe ui, roboto, arial";
      ctx.globalAlpha = 0.8 + 0.2 * Math.sin(t * 6);
      ctx.shadowBlur = 6;
      ctx.shadowColor = multColor;
      ctx.fillText("x" + multiplier.toFixed(1), 95, 55);
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
    }
    
    ctx.fillStyle = "#9ca3af";
    ctx.font = "12px system-ui, -apple-system, segoe ui, roboto, arial";
    ctx.fillText("BEST: " + best, 20, 72);
    
    if (comboCount > 2) {
      ctx.fillStyle = "#ffb86b";
      ctx.font = "bold 11px system-ui, -apple-system, segoe ui, roboto, arial";
      ctx.fillText("COMBO: " + Math.floor(comboCount), 20, 88);
    }

    const cd = player.dashCd;
    const pct = 1 - clamp(cd/0.75, 0, 1);
    
    ctx.fillStyle = "rgba(26,31,46,0.6)";
    ctx.strokeStyle = "rgba(110,231,183,0.2)";
    ctx.beginPath();
    ctx.roundRect(10, 108, 140, 32, 12);
    ctx.fill();
    ctx.stroke();
    
    ctx.fillStyle = "#9ca3af";
    ctx.font = "11px system-ui, -apple-system, segoe ui, roboto, arial";
    ctx.fillText("DASH", 20, 122);
    
    ctx.fillStyle = "rgba(0,0,0,0.3)";
    ctx.beginPath();
    ctx.roundRect(20, 126, 120, 8, 4);
    ctx.fill();
    
    if (pct > 0) {
      const barGrad = ctx.createLinearGradient(20, 0, 20 + 120 * pct, 0);
      barGrad.addColorStop(0, '#6ee7b7');
      barGrad.addColorStop(1, '#4ade80');
      ctx.fillStyle = barGrad;
      ctx.globalAlpha = 0.5 + 0.5 * pct;
      ctx.beginPath();
      ctx.roundRect(20, 126, 120 * pct, 8, 4);
      ctx.fill();
      
      if (pct === 1) {
        ctx.globalAlpha = 0.3 + 0.3 * Math.sin(t * 8);
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#6ee7b7';
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    }
    ctx.globalAlpha = 1;

    if (!alive) {
      ctx.fillStyle = "rgba(11,15,20,0.85)";
      ctx.fillRect(0, 0, w, h);
      
      ctx.fillStyle = "rgba(26,31,46,0.9)";
      ctx.strokeStyle = "rgba(110,231,183,0.3)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.roundRect(w/2 - 160, h/2 - 80, 320, 160, 16);
      ctx.fill();
      ctx.stroke();
      
      const titleGrad = ctx.createLinearGradient(0, h/2 - 50, 0, h/2 - 20);
      titleGrad.addColorStop(0, '#6ee7b7');
      titleGrad.addColorStop(1, '#9ae6ff');
      ctx.fillStyle = titleGrad;
      ctx.globalAlpha = 1;
      ctx.font = "bold 32px system-ui, -apple-system, segoe ui, roboto, arial";
      ctx.textAlign = "center";
      ctx.fillText("GAME OVER", w/2, h/2 - 20);
      
      ctx.fillStyle = "#e5e7eb";
      ctx.font = "18px system-ui, -apple-system, segoe ui, roboto, arial";
      ctx.fillText("Final Score: " + Math.floor(score), w/2, h/2 + 15);
      
      if (multiplier > 1.5) {
        ctx.fillStyle = "#ffb86b";
        ctx.font = "14px system-ui, -apple-system, segoe ui, roboto, arial";
        ctx.fillText("Max Multiplier: x" + multiplier.toFixed(1), w/2, h/2 + 38);
      }
      
      ctx.fillStyle = "#9ca3af";
      ctx.font = "14px system-ui, -apple-system, segoe ui, roboto, arial";
      ctx.fillText(isMobile ? "Tap R to restart" : "Press R to restart", w/2, h/2 + 58);
      ctx.globalAlpha = 1;
    }

    ctx.fillStyle = "#cbd5e1";
    ctx.globalAlpha = 0.6;
    ctx.font = "12px system-ui, -apple-system, segoe ui, roboto, arial";
    ctx.textAlign = "right";
    ctx.fillText(isMobile ? "joystick + DASH btn" : "SPACE dash â€¢ ESC skins", w - 14, 22);
    ctx.globalAlpha = 1;
  }

  let last = performance.now();
  function loop(now) {
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;
    if (overlay.style.display === "none") step(dt);
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
}

openSkins();
</script>
</body>
</html>
